package model;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import globals.CalendarInfo;
import globals.Configuration;
import model.Request.HourFrame;

/**
 * 
 * This class receives a well-formatted RequestList generated by model.parsers.ParserRequests
 * 
 * Recibe RequestList bien formateado del ParserRequests para validar:
 * 
 *  - Que los RequestDays de cada request tengan sentido respecto a la franja de dias de la misma
 *  - Que no se solapen request, si hay una request en el month
 * 
 * @author Jandol
 * @author Raikish
 *
 */
public class RequestPoliceman 
{
	private Map<String, RoomSchedule> roomSchedules = new HashMap<>();
	
	public RequestPoliceman() { }
	
	public Map<String, RoomSchedule> getRoomSchedules() 
	{
		return roomSchedules;
	}
	
	public void process(RequestList list)
	{	
		for(Request request : list)
		{
			if( ! roomSchedules.containsKey(request.roomName))
				roomSchedules.put(request.roomName, new RoomSchedule());
			processRequestOnSchedule(request, roomSchedules.get(request.roomName));
		}
	}

	private void processRequestOnSchedule(Request request, RoomSchedule schedule) 
	{
		// TESTME
		for(int day : getExactDays(request))
		{
			for(HourFrame hourFrame : request.hourFrames)
			{
				for(int hour = hourFrame.startHour; hour < hourFrame.endHour; hour++)
				{
					if(schedule.isEmptyHourFrame(day, hour))
					{
						schedule.get(day).put(hour, request);
					}
					else
					{
						// TODO log incompatible request (already reserved)
					}
				}
			}
		}
	}
<<<<<<< HEAD
	
	// FIXME not checking dayframe??
	/*private List<Integer> getExactDays(Request request)
	{
		List<Integer> exactDays = new ArrayList<>();
		Calendar calendar = Calendar.getInstance();
		calendar.set(Calendar.MONTH, Integer.parseInt(Configuration.MONTH_TO_PROCESS) - 1); // January = 0
		calendar.set(Calendar.YEAR, Integer.parseInt(Configuration.YEAR_TO_PROCESS));
		int maxWeek = calendar.getActualMaximum(Calendar.WEEK_OF_MONTH);
		for(int i = 1; i <= calendar.getActualMaximum(Calendar.WEEK_OF_MONTH); i++) // Correcto
		{
			calendar.set(Calendar.WEEK_OF_MONTH, i);
			int j = calendar.get(Calendar.WEEK_OF_MONTH);
			for(RequestDays requestDay : request.requestedDays)
			{
				calendar.set(Calendar.DAY_OF_WEEK, requestDay.ordinal());
				int day = calendar.get(Calendar.DAY_OF_MONTH); // CHECK esto deberia devolver algo menor a 1 si el dia no concuerda. Mirar Calendar.lenient, puede servir para detectarlo
				if(day >= request.dayFrame.startDay && day <= request.dayFrame.endDay)
					exactDays.add(day);
			}
		}
		return exactDays;
	}*/
	
=======

>>>>>>> 1b84ea39738da281f7d340155f5717363e18bf95
	private List<Integer> getExactDays(Request request)
	{
		List<Integer> exactDays = new ArrayList<>();
		Calendar calendar = Calendar.getInstance();
		calendar.set(Calendar.MONTH, (Integer.parseInt(Configuration.MONTH_TO_PROCESS) - 1));
		calendar.set(Calendar.YEAR, Integer.parseInt(Configuration.YEAR_TO_PROCESS));
		
		List<Integer> firstDays = new ArrayList<>();
		
		for(int day = request.dayFrame.startDay; day < request.dayFrame.startDay + 7 && day < CalendarInfo.MONTH_DAY_NUM; day++)
		{
			calendar.set(Calendar.DAY_OF_MONTH, day);
			int dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);
			if(maskContainsDay(request.requestedDays, dayOfWeek - 1)) { // Parchako ( Calendar.SUNDAY = 1, pero RequestDays.SUNDAY = 0)
				firstDays.add(day);
				exactDays.add(day);
			}
		}
		
		for(Integer day : firstDays)
		{
			int nextDay = day + 7;
			while (nextDay <= request.dayFrame.endDay)
			{
				exactDays.add(nextDay);
				nextDay += 7;
			}
		}
		return exactDays;
	}
	
	private boolean maskContainsDay(List<RequestDays> mask, int day) 
	{
		for(RequestDays requestedDay : mask)
		{
			if(requestedDay.ordinal() == day)
				return true;
		}
		return false;
	}
}
