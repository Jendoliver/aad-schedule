package model;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import globals.CalendarInfo;
import globals.Configuration;
import model.Request.HourFrame;

/**
 * 
 * This class receives a well-formatted RequestList generated by model.parsers.ParserRequests and
 * generates as many RoomSchedules as different roomNames on the Requests from the List. 
 * 
 * It checks for collisions between Requests and logs any incompatibility. The Map<String, RoomSchedule> generated
 * by the process(RequestList) method is zero error prone so it can be printed straight away by the OutputGenerator
 * 
 *                        ________________
                          \      __      /         __
                           \_____()_____/         /  )
                           '============`        /  /
                            #---\  /---#        /  /
                           (# @\| |/@  #)      /  /
                            \   (_)   /       /  /
                            |\ '---` /|      /  /
                    _______/ \\_____// \____/ o_|
                   /       \  /     \  /   / o_|
                  / |           o|        / o_| \
                 /  |  _____     |       / /   \ \
                /   |  |===|    o|      / /\    \ \
               |    |   \@/      |     / /  \    \ \
               |    |___________o|__/----)   \    \/
               |    '              ||  --)    \     |
               |___________________||  --)     \    /
                    |           o|   ''''   |   \__/
                    |            |          |

                      "DON'T CROSS ME... !"
 * 
 * @author Jendoliver
 * @author Raikish
 *
 */
public class RequestPoliceman 
{
	
	private static final Logger logger = LoggerFactory.getLogger(RequestPoliceman.class);
	private Map<String, RoomSchedule> roomSchedules = new HashMap<>();
	
	public RequestPoliceman() { }
	
	public Map<String, RoomSchedule> getRoomSchedules() 
	{
		return roomSchedules;
	}
	
	public void process(RequestList list)
	{	
		logger.info("# "+ Configuration.MONTH_TO_PROCESS +"/"+Configuration.YEAR_TO_PROCESS+" activity summary\n");
		for(Request request : list)
		{
			if( ! roomSchedules.containsKey(request.roomName))
				roomSchedules.put(request.roomName, new RoomSchedule());
			processRequestOnSchedule(request, roomSchedules.get(request.roomName));
		}
	}

	private void processRequestOnSchedule(Request request, RoomSchedule schedule) 
	{
		List<Integer> exactDays = getExactDays(request);
		int numHoursRequested = 0;
		int numHoursAccepted = 0;
		logger.info("# Activity: "+request.activityName);
		for(int day : exactDays)
		{
			for(HourFrame hourFrame : request.hourFrames)
			{
				for(int hour = hourFrame.startHour; hour < hourFrame.endHour; hour++)
				{
					numHoursRequested++;
					if(schedule.isEmptyHourFrame(day, hour))
					{
						schedule.get(day).put(hour, request);
						numHoursAccepted++;
					}
					else
					{
						logger.warn("Room: "+request.roomName+ " "
								+ "Day: "+day+"/"+Configuration.MONTH_TO_PROCESS+"/"+Configuration.YEAR_TO_PROCESS
								+ "Hour: "+hour+"-"+(hour+1)
								+ "Conflict with: " + schedule.getRequest(day, hour).activityName);
					}
				}
			}
		}
		logger.info("--------> Total: "+numHoursAccepted+" / "+numHoursRequested+" h assigned (Unassigned: "+(numHoursRequested-numHoursAccepted)+" h)");
	}

	private List<Integer> getExactDays(Request request)
	{
		List<Integer> exactDays = new ArrayList<>();
		Calendar calendar = Calendar.getInstance();
		calendar.set(Calendar.MONTH, (Integer.parseInt(Configuration.MONTH_TO_PROCESS) - 1));
		calendar.set(Calendar.YEAR, Integer.parseInt(Configuration.YEAR_TO_PROCESS));
		
		List<Integer> firstDays = new ArrayList<>();
		
		// Iterate for a week, but break if this gets out of month or out of the request dayFrame itself
		for(int day = request.dayFrame.startDay; day < request.dayFrame.startDay + 7 && day < CalendarInfo.MONTH_DAY_NUM && day <= request.dayFrame.endDay; day++)
		{
			calendar.set(Calendar.DAY_OF_MONTH, day);
			int dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);
			if(maskContainsDay(request.requestedDays, dayOfWeek - 1)) { // Calendar.SUNDAY = 1, but RequestDays.SUNDAY = 0) TODO solve this in a centralized place
				firstDays.add(day);
				exactDays.add(day);
			}
		}
		
		for(Integer day : firstDays)
		{
			int nextDay = day + 7;
			while (nextDay <= request.dayFrame.endDay)
			{
				exactDays.add(nextDay);
				nextDay += 7;
			}
		}
		return exactDays;
	}
	
	private boolean maskContainsDay(List<RequestDays> mask, int day) 
	{
		for(RequestDays requestedDay : mask)
		{
			if(requestedDay.ordinal() == day)
				return true;
		}
		return false;
	}
}
