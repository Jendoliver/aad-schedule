package model;

import java.util.HashMap;
import java.util.Map;

import model.Request.HourFrame;

/**
 * 
 * This class receives a well-formatted RequestList generated by model.parsers.ParserRequests
 * 
 * Recive RequestList bien formateado del ParserRequests para validar:
 * 
 *  - Que los RequestDays de cada request tengan sentido respecto a la franja de dias de la misma
 *  - Que no se solapen request, si hay una request en el month
 * 
 * @author Jandol
 * @author Raikish
 *
 */
public class RequestPoliceman 
{
	private Map<String, RoomSchedule> roomSchedules = new HashMap<>();
	
	public RequestPoliceman() { }
	
	public Map<String, RoomSchedule> getRoomSchedules() 
	{
		return roomSchedules;
	}
	
	public void process(RequestList list)
	{	
		for(Request request : list)
		{
			// Si los RequestDays de la request tienen sentido respecto a la franja de dias de la misma
				if(isExistingRoom(request.roomName))
					processRequestOnSchedule(request, roomSchedules.get(request.roomName));
				else
					processRequestOnSchedule(request, roomSchedules.put(request.roomName, new RoomSchedule()));
		}
	}

	private void processRequestOnSchedule(Request request, RoomSchedule schedule) 
	{
		for(int day = request.dayFrame.startDay; day <= request.dayFrame.endDay; day++)
		{
			for(HourFrame hourFrame : request.hourFrames)
			{
				for(int hour = hourFrame.startHour; hour < hourFrame.endHour; hour++)
				{
					if(schedule.isEmptyHourFrame(day, hour))
					{
						Map<Integer, Map<Integer, Request>> grid = schedule.getGrid();
						Map<Integer, Request> dayHours = grid.get(day);
						dayHours.put(hour, request);
					}
					else
					{
						// TODO log incompatible request (already reserved)
					}
				}
			}
		}
	}
	
	private boolean isExistingRoom(String roomName) 
	{
		return roomSchedules.containsKey(roomName);
	}
}
